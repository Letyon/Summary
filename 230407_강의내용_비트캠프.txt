2023-04-07 9일차 강의일지

<주말 과제>
각 chapter별로 연습용 프로젝트 생성하기(chap00 ~)
-> '점프 투 자바'교재의 코드예제 작성하기(변수명 뒤에, 식별하기 위한 자리번호 붙이기) 
-> export해서 채종훈 강사님께 보내기

* 장비세팅 : 듀얼모니터 > 모니터암 > 키보드 > 의자

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
상수는 전부 다 대문자로 표기할 것
매직넘버보다 변수나 상수로 지정하면, 코드 유지보수성이 좋아진다.
유지보수성 측면에서, @annotation해주는 것이 좋음

Constructor(생성자)
- 생성자 내부 변수는 '지역변수'라고 정의
- 생성자에서는 주소밖에 호출이 안 되므로, return구문을 쓰지 않음

Class(클래스)
- 클래스 내부 변수는 '멤버변수'라고 정의

--> 멤버변수에 지역변수를 다른 이름으로 저장함

garbage collecting = 메모리에 필요없는 자료를 삭제해주는 것
garbage = 스택과 힙 사이의 연결이 끊어진 인스턴스

F2로 이름 바꾸기 -> 내부 코드의 이름도 자동 변경됨

패키지는 소문자로만 표기
메서드는 카멜표기법
클래스명은 파스칼표기법

상위폴더명dot(.)하위폴더명

패키지 = 클래스 묶어서 관리(폴더 구분)
(*기호를 사용하면, 모든 클래스 사용 가능)
(import를 사용하면, 다른 패키지의 클래스 사용 가능)
(import 없이도, 같은 패키지의 클래스는 사용 가능)

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
<AllInOne(요약 압축 정리)>

스태틱 영역 = (전역변수, 필드, 메서드) 저장
스택 영역 = (지역변수, 주소값) 저장
힙 영역 = (인스턴스, 실제값) 저장

## 코드 구조 ##
1. 스태틱 영역(전역변수 저장) == (상단)스태틱 영역(클래스 = 필드 + 메서드)
클래스(설계도) 생성
= (필드(멤버변수) + 메서드(멤버메서드)) 생성
= 상수(고정변수) 선언
= 생성자(멤버변수 초기화) 생성

2. 힙 영역(참조형식 저장) == (우변)힙 영역(힙의 주소번지에 스태틱의 설계도를 바탕으로 만들어진 인스턴스가 저장)
new로 인스턴스(객체) 생성
= 설계도의 참조형식(변수 + 메서드) 생성

3. 스택 영역(main 호출하여 인스턴스 실행) == (좌변)스택 영역(각 지역변수에 힙의 주소번지가 저장)
힙의 인스턴스(객체) 구현
= 지역변수(생성된 힙의 주소 저장).메서드(동작 구현)

## 로직 구현순서 과정 ##
((1번 상단)) 스태틱 영역(전역변수가 저장되는 곳) --> class Human에 [필드(멤버변수들(name, age 등))와 메서드(실행구문 등)]가 정의됨
((2번 우변)) 힙 영역(참조 형식이 저장되는 곳) --> Human h1 = new Human(); -> new에 의해 (Human 클래스에 있는 정보 기반의)인스턴스(*주소번지[필드 + 메서드])가 생성됨
((3번 좌변)) 스택 영역(main이 호출되어 인스턴스가 실행되는 곳) --> Human h1 = new Human(); -> 힙의*주소번지를 지역변수(h1)에 저장함
((4번))
h1.name = "이찬희" --> h1(힙의*주소번지)의 name에 "이찬희"라고 저장
h1.age = 32 --> h1(힙의*주소번지)의 age에 32라고 저장
((5번))
h1.showInfo(); --> h1(힙의*주소번지)의 showInfo()메서드를 실행

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
스택에 있는 주소값 비교(==, != 연산자)
힙에 있는 실제값 비교(equals()메서드)

String str1 = "Hello";
String str2 = "Hello";
--> 문자열 자체는 불변객체이므로, 동일한 주소값을 가짐

String str3 = new String("Hello");
String str4 = new String("Hello");
--> 힙에 생성된 문자열은, 다른 주소값을 가짐

class a(부모 클래스 하나에 있는 속성들)를 class b, c, d 등(class a의 속성들을 자식 클래스의 여러 개)에게 상속

<배열(참조형 변수)>
int[] intArray1 = {1, 2, 3, 4, 5}; ㅡ> 얕은 복사(단순히 [1, 2, 3, 4, 5]의 *100번지 주소를 intArray1 배열변수에 복사)
Arrays.toString(intArray1); ㅡ> intArray1 배열변수 *100번지 주소의 실제값인 [1, 2, 3, 4, 5]를 찾아서 나타냄
int[] intArray2 = intArray1.clone(); ㅡ> 깊은 복사(intArray1 배열변수의 *100번지 주소 실제값을 intArray2 배열변수의 *200번지 주소로 복사)

Arrays.toString(주소값) = 주소에 있는 실제값을 찾아서 나타나도록 함

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
<소스트리 - 깃허브>
push = 로컬1(pc1에서 작업한 최신파일)에서 원격(깃허브)으로 올리기
push = 로컬2(pc2에서 작업한 최신파일)에서 원격(깃허브)으로 올리기

clone(.git이 없을 때 최초 1회) = 원격(push한 깃허브의 최신파일)에서 로컬(pc1 or pc2)으로 내려받기
pull(.git이 있으면 pull로 하면 됨) = 원격(push한 깃허브의 최신파일)에서 로컬(pc1 or pc2)으로 내려받기

